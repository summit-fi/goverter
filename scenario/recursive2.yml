input:
    input.go: |
        package structs

        // goverter:converter
        type Converter interface {
            Convert(source Input) Output
        }

        type Input struct {
            Value *InputA
        }
        type Output struct {
            Value *OutputA
        }

        type InputA struct {
            Value *InputB
        }
        type InputB struct {
            Value *InputA
        }
        type OutputA struct {
            Value *OutputB
        }
        type OutputB struct {
            Value *OutputA
        }
success:
    - generated/generated.go: |
        // Code generated by github.com/jmattheis/goverter, DO NOT EDIT.

        package generated

        import execution "github.com/emp1re/goverter-test/execution"

        type ConverterImpl struct{}

        func (c *ConverterImpl) Convert(source execution.Input) execution.Output {
        	var structsOutput execution.Output
        	structsOutput.Value = c.pStructsInputAToPStructsOutputA(source.Value)
        	return structsOutput
        }
        func (c *ConverterImpl) pStructsInputAToPStructsOutputA(source *execution.InputA) *execution.OutputA {
        	var pStructsOutputA *execution.OutputA
        	if source != nil {
        		var structsOutputA execution.OutputA
        		structsOutputA.Value = c.pStructsInputBToPStructsOutputB((*source).Value)
        		pStructsOutputA = &structsOutputA
        	}
        	return pStructsOutputA
        }
        func (c *ConverterImpl) pStructsInputBToPStructsOutputB(source *execution.InputB) *execution.OutputB {
        	var pStructsOutputB *execution.OutputB
        	if source != nil {
        		var structsOutputB execution.OutputB
        		structsOutputB.Value = c.pStructsInputAToPStructsOutputA((*source).Value)
        		pStructsOutputB = &structsOutputB
        	}
        	return pStructsOutputB
        }
