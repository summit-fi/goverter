input:
    input.go: |
        package structs

        // goverter:converter
        type Converter interface {
            Convert(source Input) Output
        }

        type X struct {
            Y *Y
        }
        type Y struct {
            Z *Z
        }
        type Z struct {
            Z string
        }

        type Input struct {
            X **X
        }
        type Output struct {
            X **X
        }
success:
    - generated/generated.go: |
        // Code generated by github.com/jmattheis/goverter, DO NOT EDIT.

        package generated

        import execution "github.com/emp1re/goverter-test/execution"

        type ConverterImpl struct{}

        func (c *ConverterImpl) Convert(source execution.Input) execution.Output {
        	var structsOutput execution.Output
        	var pPStructsX **execution.X
        	if source.X != nil {
        		pStructsX := c.pStructsXToPStructsX((*source.X))
        		pPStructsX = &pStructsX
        	}
        	structsOutput.X = pPStructsX
        	return structsOutput
        }
        func (c *ConverterImpl) pStructsXToPStructsX(source *execution.X) *execution.X {
        	var pStructsX *execution.X
        	if source != nil {
        		var structsX execution.X
        		structsX.Y = c.pStructsYToPStructsY((*source).Y)
        		pStructsX = &structsX
        	}
        	return pStructsX
        }
        func (c *ConverterImpl) pStructsYToPStructsY(source *execution.Y) *execution.Y {
        	var pStructsY *execution.Y
        	if source != nil {
        		var structsY execution.Y
        		structsY.Z = c.pStructsZToPStructsZ((*source).Z)
        		pStructsY = &structsY
        	}
        	return pStructsY
        }
        func (c *ConverterImpl) pStructsZToPStructsZ(source *execution.Z) *execution.Z {
        	var pStructsZ *execution.Z
        	if source != nil {
        		var structsZ execution.Z
        		structsZ.Z = (*source).Z
        		pStructsZ = &structsZ
        	}
        	return pStructsZ
        }
